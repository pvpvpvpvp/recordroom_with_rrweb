<!doctype html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>RecordRoom Week5 Demo (legacy inline)</title>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system; padding: 20px; line-height: 1.4; }
    button, input { padding: 10px 14px; margin-right: 8px; margin-bottom: 8px; }
    code { background: #f6f6f6; padding: 2px 6px; border-radius: 6px; }
    .box { border: 1px solid #ddd; border-radius: 10px; padding: 12px; margin-top: 12px; }
    .row { margin: 6px 0; }
    a { word-break: break-all; }
    .small { color: #666; font-size: 12px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 8px; }
    @media (min-width: 900px) {
      .grid { grid-template-columns: 1fr 1fr; }
    }
    .pill { display: inline-block; background: #f4f4f4; padding: 2px 8px; border-radius: 999px; font-size: 12px; }
  </style>
  <script src="/js/i18n.js"></script>
</head>
<body>
  <h1><span data-i18n-en="RecordRoom Week5 Demo (legacy inline)" data-i18n-ko="RecordRoom Week5 데모(기존 방식)">RecordRoom Week5 데모(기존 방식)</span></h1>

  <div class="box">
    <div class="row tabs">
      <a href="/demo" class="active"><span data-i18n-en="Demo (Legacy)" data-i18n-ko="데모(기존)">데모(기존)</span></a>
      <a href="/demo-sdk"><span data-i18n-en="Demo (SDK)" data-i18n-ko="데모(SDK)">데모(SDK)</span></a>
      <a href="/sdk-install"><span data-i18n-en="SDK Install Guide" data-i18n-ko="SDK 설치/연동 가이드">SDK 설치/연동 가이드</span></a>
      <a href="/admin" target="_blank"><span data-i18n-en="Admin" data-i18n-ko="관제">관제</span></a>
      <span class="small" style="margin-left:12px;">
        <a href="#" data-lang-toggle="ko">KR</a> /
        <a href="#" data-lang-toggle="en">EN</a>
      </span>
    </div>
  </div>

  <div class="box">
    <div class="row"><b>Step 1.</b> 아래 버튼으로 기록방을 생성합니다.</div>
    <button id="btnCreate">기록방 생성</button>
    <span class="pill">Previous Record 자동 연결</span>
    <div class="row">Record ID: <code id="recordId">-</code></div>
    <div class="row">Previous Record: <code id="prevId">-</code></div>
    <div class="row">Share URL: <a id="shareUrl" href="#" target="_blank">-</a></div>
    <div class="row">WS: <code id="wsUrl">-</code></div>
    <div class="row small">appVersion: <span th:text="${appVersion}">0.3.0</span></div>
  </div>

  <div class="box grid">
    <div>
      <div class="row"><b>Step 2-A.</b> Console 이벤트</div>
      <button id="btnLog">console.log</button>
      <button id="btnWarn">console.warn</button>
      <button id="btnError">console.error</button>
      <button id="btnThrow">throw Error</button>
    </div>
    <div>
      <div class="row"><b>Step 2-B.</b> Network 이벤트</div>
      <div class="row small">※ 서버의 /demo/api/* 로 호출됩니다.</div>
      <button id="btnFetchOk">fetch GET ok</button>
      <button id="btnFetchSlow">fetch GET slow</button>
      <button id="btnFetchFail">fetch GET fail(500)</button>
      <button id="btnFetchPost">fetch POST echo</button>
      <br/>
      <button id="btnXhrOk">XHR GET ok</button>
      <button id="btnXhrSlow">XHR GET slow</button>
      <button id="btnXhrFail">XHR GET fail(500)</button>
      <button id="btnXhrPost">XHR POST echo</button>
    </div>
  </div>

  <div class="box">
    <div class="row"><b>Step 2-C.</b> Breadcrumb 이벤트 (유저 액션)</div>
    <div class="row small">아래 입력/버튼 클릭, 그리고 브라우저 뒤로가기/앞으로가기, 주소 변경(History)을 해보세요.</div>
    <input id="demoInput" placeholder="입력해보세요 (input/change 기록됨)" style="width: 320px;" />
    <button id="btnCustomBreadcrumb">커스텀 breadcrumb</button>
    <button id="btnPushState">history.pushState</button>
  </div>

  <div class="box">
    <div class="row"><b>Step 3.</b> Share URL을 열고 Timeline/Console/Network/Breadcrumbs 탭을 확인합니다.</div>
    <div class="row small">Timeline: /r/{recordId}/timeline</div>
    <div class="row small">Console: /r/{recordId}/console</div>
    <div class="row small">Network: /r/{recordId}/network</div>
    <div class="row small">Breadcrumbs: /r/{recordId}/breadcrumbs</div>
  </div>

<script th:inline="javascript">
/*<![CDATA[*/
(function(){
  const MAX_BODY = 20000; // 20KB
  const MAX_INPUT = 200; // mask/truncate
  const SDK = {
    apiBase: window.location.origin,
    recordId: null,
    ws: null,
    seq: 0,
    queue: [],
    isPatchingConsole: false,
    isPatchingNetwork: false,
    isPatchingBreadcrumb: false,

    async createRecord() {
      const sessionId = (sessionStorage.getItem("rr_sessionId") || crypto.randomUUID());
      sessionStorage.setItem("rr_sessionId", sessionId);

      const prev = sessionStorage.getItem("rr_lastRecordId");
      const payload = {
        pageUrl: window.location.href,
        userAgent: navigator.userAgent,
        appVersion: [[${appVersion}]],
        sessionId: sessionId,
        previousRecordId: prev ? prev : null
      };

      const res = await fetch(this.apiBase + "/api/records", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload)
      });
      const data = await res.json();

      this.recordId = data.recordId;
      sessionStorage.setItem("rr_recordId", this.recordId);
      sessionStorage.setItem("rr_lastRecordId", this.recordId);

      document.getElementById("recordId").textContent = data.recordId;
      document.getElementById("prevId").textContent = prev ? prev : "-";
      document.getElementById("wsUrl").textContent = data.ingestWsUrl;
      const a = document.getElementById("shareUrl");
      a.textContent = data.shareUrl;
      a.href = data.shareUrl;

      this.openWs(data.ingestWsUrl);
      this.patchConsoleOnce();
      this.patchNetworkOnce();
      this.patchBreadcrumbOnce();

      this.breadcrumb("custom", "record created", { recordId: this.recordId, previousRecordId: prev ? prev : "" });
      console.log("Record created:", this.recordId, "prev=", prev);
      return data;
    },

    openWs(wsUrl) {
      if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
        return;
      }
      this.ws = new WebSocket(wsUrl);

      this.ws.addEventListener("open", () => {
        this.flush();
      });

      this.ws.addEventListener("close", () => {
        setTimeout(() => {
          if (this.recordId) {
            const url = this.apiBase.replace(/^http/, "ws") + "/ws/ingest?recordId=" + this.recordId;
            this.openWs(url);
          }
        }, 1000);
      });
    },

    enqueue(evt) {
      this.queue.push(evt);
      this.flush();
    },

    flush() {
      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
      while (this.queue.length > 0) {
        const evt = this.queue.shift();
        try {
          this.ws.send(JSON.stringify(evt));
        } catch (e) {
          this.queue.unshift(evt);
          break;
        }
      }
    },

    // ---------- Console ----------
    patchConsoleOnce() {
      if (this.isPatchingConsole) return;
      this.isPatchingConsole = true;

      const origLog = console.log.bind(console);
      const origWarn = console.warn.bind(console);
      const origError = console.error.bind(console);

      const send = (level, args) => {
        const msg = args.map(a => {
          try {
            if (typeof a === "string") return a;
            return JSON.stringify(a);
          } catch(e) {
            return String(a);
          }
        }).join(" ");

        this.seq += 1;

        const evt = {
          type: "console",
          level: level,
          message: msg,
          stack: null,
          ts: Date.now(),
          seq: this.seq
        };
        this.enqueue(evt);
      };

      console.log = (...args) => { origLog(...args); send("log", args); };
      console.warn = (...args) => { origWarn(...args); send("warn", args); };
      console.error = (...args) => { origError(...args); send("error", args); };

      window.addEventListener("error", (e) => {
        this.seq += 1;
        const evt = {
          type: "console",
          level: "error",
          message: (e && e.message) ? e.message : "window.error",
          stack: (e && e.error && e.error.stack) ? e.error.stack : null,
          ts: Date.now(),
          seq: this.seq
        };
        this.enqueue(evt);
      });

      window.addEventListener("unhandledrejection", (e) => {
        this.seq += 1;
        const evt = {
          type: "console",
          level: "error",
          message: (e && e.reason) ? (typeof e.reason === "string" ? e.reason : JSON.stringify(e.reason)) : "unhandledrejection",
          stack: null,
          ts: Date.now(),
          seq: this.seq
        };
        this.enqueue(evt);
      });
    },

    // ---------- Network ----------
    patchNetworkOnce() {
      if (this.isPatchingNetwork) return;
      this.isPatchingNetwork = true;

      const isInternalUrl = (url) => {
        try {
          const u = new URL(url, window.location.href);
          return u.pathname.startsWith("/api/records") || u.pathname.startsWith("/ws/ingest");
        } catch (e) { return false; }
      };

      const truncate = (s) => {
        if (typeof s !== "string") return s;
        return (s.length > MAX_BODY) ? (s.slice(0, MAX_BODY) + "\n...[truncated]") : s;
      };

      // fetch patch
      const originalFetch = window.fetch.bind(window);
      window.fetch = async (...args) => {
        const startedAt = Date.now();
        const clientRequestId = "f_" + crypto.randomUUID();
        let method = "GET";
        let url = "";
        let requestHeaders = {};
        let requestBody = null;

        try {
          const input = args[0];
          const init = args[1] || {};

          if (input instanceof Request) {
            url = input.url;
            method = input.method || method;
            input.headers && input.headers.forEach((v, k) => requestHeaders[k] = v);
          } else {
            url = String(input);
          }

          if (init.method) method = init.method;

          if (init.headers) {
            if (init.headers instanceof Headers) {
              init.headers.forEach((v, k) => requestHeaders[k] = v);
            } else if (Array.isArray(init.headers)) {
              for (const [k, v] of init.headers) requestHeaders[String(k)] = String(v);
            } else if (typeof init.headers === "object") {
              Object.assign(requestHeaders, init.headers);
            }
          }

          if (init.body != null) {
            if (typeof init.body === "string") requestBody = init.body;
            else if (init.body instanceof URLSearchParams) requestBody = init.body.toString();
            else requestBody = "[non-string body]";
          }
        } catch (e) {}

        let response;
        let status = 0;
        let responseHeaders = {};
        let responseBody = null;
        let error = null;

        try {
          response = await originalFetch(...args);
          status = response.status;

          try { response.headers && response.headers.forEach((v, k) => responseHeaders[k] = v); } catch (e) {}

          try {
            const cloned = response.clone();
            const text = await cloned.text();
            responseBody = truncate(text);
          } catch (e) {
            responseBody = "[unreadable body]";
          }

          return response;
        } catch (e) {
          error = (e && e.message) ? e.message : String(e);
          throw e;
        } finally {
          const durationMs = Date.now() - startedAt;
          if (!isInternalUrl(url)) {
            SDK.seq += 1;
            SDK.enqueue({
              type: "network",
              clientRequestId,
              method,
              url,
              status,
              requestHeaders,
              requestBody: requestBody ? truncate(requestBody) : null,
              responseHeaders,
              responseBody: responseBody ? truncate(responseBody) : null,
              startedAtEpochMs: startedAt,
              durationMs,
              error,
              seq: SDK.seq
            });
          }
        }
      };

      // XHR patch
      const OriginalXHR = window.XMLHttpRequest;
      function PatchedXHR() {
        const xhr = new OriginalXHR();
        let _method = "GET";
        let _url = "";
        let _reqHeaders = {};
        let _reqBody = null;
        const _clientRequestId = "x_" + crypto.randomUUID();
        let _startedAt = 0;

        const origOpen = xhr.open;
        xhr.open = function(method, url, async, user, password) {
          _method = method || "GET";
          _url = url ? String(url) : "";
          return origOpen.apply(xhr, arguments);
        };

        const origSetHeader = xhr.setRequestHeader;
        xhr.setRequestHeader = function(k, v) {
          _reqHeaders[String(k)] = String(v);
          return origSetHeader.apply(xhr, arguments);
        };

        const origSend = xhr.send;
        xhr.send = function(body) {
          _startedAt = Date.now();
          if (body != null) {
            if (typeof body === "string") _reqBody = body;
            else _reqBody = "[non-string body]";
          }
          xhr.addEventListener("loadend", function() {
            const status = xhr.status || 0;
            const durationMs = Date.now() - _startedAt;
            let resHeaders = {};
            try {
              const raw = xhr.getAllResponseHeaders() || "";
              raw.trim().split(/\r?\n/).forEach(line => {
                const idx = line.indexOf(":");
                if (idx > 0) {
                  const k = line.slice(0, idx).trim();
                  const v = line.slice(idx + 1).trim();
                  resHeaders[k] = v;
                }
              });
            } catch (e) {}

            let resBody = null;
            try {
              resBody = xhr.responseText;
              if (typeof resBody !== "string") resBody = "[non-text response]";
            } catch (e) {
              resBody = "[unreadable body]";
            }

            const err = (status === 0 && xhr.statusText) ? xhr.statusText : null;

            if (!isInternalUrl(_url)) {
              SDK.seq += 1;
              SDK.enqueue({
                type: "network",
                clientRequestId: _clientRequestId,
                method: _method,
                url: _url,
                status,
                requestHeaders: _reqHeaders,
                requestBody: _reqBody ? truncate(_reqBody) : null,
                responseHeaders: resHeaders,
                responseBody: resBody ? truncate(resBody) : null,
                startedAtEpochMs: _startedAt,
                durationMs,
                error: err,
                seq: SDK.seq
              });
            }
          });

          return origSend.apply(xhr, arguments);
        };

        return xhr;
      }
      window.XMLHttpRequest = PatchedXHR;
    },

    // ---------- Breadcrumb ----------
    patchBreadcrumbOnce() {
      if (this.isPatchingBreadcrumb) return;
      this.isPatchingBreadcrumb = true;

      const safeText = (s) => {
        if (s == null) return "";
        const t = String(s);
        return t.length > MAX_INPUT ? (t.slice(0, MAX_INPUT) + "...") : t;
      };

      const selectorOf = (el) => {
        try {
          if (!el) return "";
          const parts = [];
          let cur = el;
          for (let i = 0; i < 4 && cur; i++) {
            let part = cur.tagName ? cur.tagName.toLowerCase() : "node";
            if (cur.id) part += "#" + cur.id;
            if (cur.classList && cur.classList.length > 0) {
              part += "." + Array.from(cur.classList).slice(0, 2).join(".");
            }
            parts.unshift(part);
            cur = cur.parentElement;
          }
          return parts.join(" > ");
        } catch (e) { return ""; }
      };

      document.addEventListener("click", (e) => {
        const t = e.target;
        const msg = "click " + selectorOf(t);
        const data = {
          selector: selectorOf(t),
          text: safeText(t && t.innerText ? t.innerText : ""),
          href: (t && t.href) ? String(t.href) : "",
        };
        this.breadcrumb("click", msg, data);
      }, true);

      document.addEventListener("input", (e) => {
        const t = e.target;
        if (!t || !t.tagName) return;
        const tag = t.tagName.toLowerCase();
        if (tag !== "input" && tag !== "textarea" && tag !== "select") return;

        const type = (t.type || "").toLowerCase();
        const isPwd = (type === "password");
        const value = isPwd ? "[masked]" : safeText(t.value);

        const msg = "input " + selectorOf(t);
        const data = {
          selector: selectorOf(t),
          name: t.name ? String(t.name) : "",
          value: value
        };
        this.breadcrumb("input", msg, data);
      }, true);

      // history navigation
      const originalPushState = history.pushState.bind(history);
      history.pushState = (...args) => {
        const before = location.href;
        const ret = originalPushState(...args);
        const after = location.href;
        this.breadcrumb("navigation", "history.pushState", { before, after });
        return ret;
      };

      const originalReplaceState = history.replaceState.bind(history);
      history.replaceState = (...args) => {
        const before = location.href;
        const ret = originalReplaceState(...args);
        const after = location.href;
        this.breadcrumb("navigation", "history.replaceState", { before, after });
        return ret;
      };

      window.addEventListener("popstate", () => {
        this.breadcrumb("navigation", "popstate", { href: location.href });
      });
    },

    breadcrumb(name, message, data) {
      this.seq += 1;
      this.enqueue({
        type: "breadcrumb",
        name: name,
        message: message,
        data: data || {},
        ts: Date.now(),
        seq: this.seq
      });
    }
  };

  // UI bindings
  document.getElementById("btnCreate").addEventListener("click", async () => {
    await SDK.createRecord();
  });

  document.getElementById("btnLog").addEventListener("click", () => console.log("hello", {a: 1, b: 2}));
  document.getElementById("btnWarn").addEventListener("click", () => console.warn("warn happened", {time: new Date().toISOString()}));
  document.getElementById("btnError").addEventListener("click", () => console.error("error happened", {code: "E_DEMO"}));
  document.getElementById("btnThrow").addEventListener("click", () => { throw new Error("boom! thrown error for demo"); });

  document.getElementById("btnFetchOk").addEventListener("click", async () => {
    const r = await fetch("/demo/api/ok");
    console.log("fetch ok status=", r.status);
  });

  document.getElementById("btnFetchSlow").addEventListener("click", async () => {
    const r = await fetch("/demo/api/slow?ms=900");
    console.log("fetch slow status=", r.status);
  });

  document.getElementById("btnFetchFail").addEventListener("click", async () => {
    const r = await fetch("/demo/api/fail");
    console.log("fetch fail status=", r.status);
  });

  document.getElementById("btnFetchPost").addEventListener("click", async () => {
    const r = await fetch("/demo/api/echo", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({orderId: "O-" + Date.now(), amount: 12000})
    });
    console.log("fetch post status=", r.status);
  });

  function xhr(method, url, body) {
    return new Promise((resolve, reject) => {
      const x = new XMLHttpRequest();
      x.open(method, url, true);
      if (body != null) x.setRequestHeader("Content-Type", "application/json");
      x.onload = () => resolve({status: x.status, text: x.responseText});
      x.onerror = () => reject(new Error("xhr error"));
      x.send(body);
    });
  }

  document.getElementById("btnXhrOk").addEventListener("click", async () => {
    const r = await xhr("GET", "/demo/api/ok");
    console.log("xhr ok status=", r.status);
  });

  document.getElementById("btnXhrSlow").addEventListener("click", async () => {
    const r = await xhr("GET", "/demo/api/slow?ms=700");
    console.log("xhr slow status=", r.status);
  });

  document.getElementById("btnXhrFail").addEventListener("click", async () => {
    const r = await xhr("GET", "/demo/api/fail");
    console.log("xhr fail status=", r.status);
  });

  document.getElementById("btnXhrPost").addEventListener("click", async () => {
    const r = await xhr("POST", "/demo/api/echo", JSON.stringify({userId: "U-" + Date.now(), action: "click"}));
    console.log("xhr post status=", r.status);
  });

  // Custom breadcrumbs
  document.getElementById("btnCustomBreadcrumb").addEventListener("click", () => {
    if (!SDK.recordId) {
      alert("먼저 기록방 생성하세요");
      return;
    }
    SDK.breadcrumb("custom", "custom breadcrumb clicked", { note: "hello from custom button", ts: String(Date.now()) });
  });

  document.getElementById("btnPushState").addEventListener("click", () => {
    history.pushState({demo:true}, "", "?demo=" + Date.now());
  });

  document.getElementById("demoInput").addEventListener("change", () => {
    // input event already captured, but we add console log for visibility
    console.log("input changed");
  });
})();
 /*]]>*/
</script>
</body>
</html>
